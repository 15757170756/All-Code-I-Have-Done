/*
时间限制：1秒

空间限制：32768K

小易正在玩一款新出的射击游戏,这个射击游戏在一个二维平面进行,
小易在坐标原点(0,0),平面上有n只怪物,每个怪物有所在的坐标(x[i], y[i])。
小易进行一次射击会把x轴和y轴上(包含坐标原点)的怪物一次性消灭。
小易是这个游戏的VIP玩家,他拥有两项特权操作:
1、让平面内的所有怪物同时向任意同一方向移动任意同一距离
2、让平面内的所有怪物同时对于小易(0,0)旋转任意同一角度
小易要进行一次射击。小易在进行射击前,可以使用这两项特权操作任意次。
小易想知道在他射击的时候最多可以同时消灭多少只怪物,请你帮帮小易。

如样例所示:

所有点对于坐标原点(0,0)顺时针或者逆时针旋转45°,
可以让所有点都在坐标轴上,所以5个怪物都可以消灭。

输入描述:
输入包括三行。
第一行中有一个正整数n(1 ≤ n ≤ 50),表示平面内的怪物数量。
第二行包括n个整数x[i](-1,000,000 ≤ x[i] ≤ 1,000,000),
表示每只怪物所在坐标的横坐标,以空格分割。
第二行包括n个整数y[i](-1,000,000 ≤ y[i] ≤ 1,000,000),
表示每只怪物所在坐标的纵坐标,以空格分割。

输出描述:
输出一个整数表示小易最多能消灭多少只怪物。

输入例子1:
5
0 -1 1 1 -1
0 -1 -1 1 1

输出例子1:
5
*/




/*
四个for循环。每个for循环选取一个点（判断该点不同于前面的点），
前三个点要求不共线。
前两个点A,B通过第一条直线；
第三个点C通过另一条直线；
第四个for循环，对于剩下的n-3个点，
判断是否落在这两条直线上。如果有AD与AB平行，
则落在第一条直线上；如果有CD与AB垂直，则落在第二条直线上。
第四个for循环结束，可以知道这两条直线能穿过最多几个点，
每次更新最大值。
所有循环结束，输出最终的最大值即可。
计算斜率来判断平行和垂直，即dx1 * dy2 == dy1 *dx2。


注意到允许的移动和旋转都是对于怪物整体而言的,
那么其实等价于整个坐标轴做移动或者旋转。
然后我们现在要移动或者旋转之后在坐标轴上的点最多,
坐标轴肯定是由给定点集来组成的,
接下来的问题就是枚举坐标轴统计就好了,中间会涉及到直线的垂直和平行的判断。
*/

#include<stdio.h>
#define max(a,b) a>b?a:b
const int maxn = 55;
int dx[maxn][maxn], dy[maxn][maxn], x[maxn], y[maxn];
int main()
{
	int n, i, j, k, q, res, Max = -1;

	for (scanf("%d", &n), i = 0; i < n; i++) 
		scanf("%d", &x[i]);

	for (i = 0; i < n; i++) 
		scanf("%d", &y[i]);

	for (i = 0; i < n; i++)
		for (j = 0; j < n; j++) dx[i][j] = x[j] - x[i], dy[i][j] = y[j] - y[i];
	for (i = 0; i < n; i++)
		for (j = i + 1; j < n; j++)
			for (k = 0; k < n; k++)
				if (k != i && k != j && 
					dy[i][j] * dx[i][k] != dy[i][k] * dx[i][j]) {
					for (q = 0, res = 0; q < n; q++)
						if (dy[i][j] * dx[i][q] == dy[i][q] * dx[i][j]
							|| dy[i][j] * dy[k][q] == -dx[i][j] * dx[k][q])
							res++;
					Max = max(Max, res);
				}
	printf("%d\n", Max + 1 ? Max : n);
}