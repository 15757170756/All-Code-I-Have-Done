/*
链接：https://www.nowcoder.com/acm/contest/5/C
来源：牛客网

锦标赛
时间限制：C/C++ 1秒，其他语言2秒
空间限制：C/C++ 32768K，其他语言65536K
64bit IO Format: %lld
题目描述 
组委会正在为美团点评CodeM大赛的决赛设计新赛制。

比赛有 n 个人参加（其中 n 为2的幂），
每个参赛者根据资格赛和预赛、复赛的成绩，
会有不同的积分。比赛采取锦标赛赛制，
分轮次进行，设某一轮有 m 个人参加，
那么参赛者会被分为 m/2 组，每组恰好 2 人，
m/2 组的人分别厮杀。我们假定积分高的人肯定获胜，
若积分一样，则随机产生获胜者。
获胜者获得参加下一轮的资格，输的人被淘汰。
重复这个过程，直至决出冠军。

现在请问，参赛者小美最多可以活到第几轮（初始为第0轮）？
输入描述:
第一行一个整数 n (1≤n≤ 2^20)，表示参加比赛的总人数。

接下来 n 个数字（数字范围：-1000000…1000000），表示每个参赛者的积分。

小美是第一个参赛者。
输出描述:
小美最多参赛的轮次。
示例1
输入
4
4 1 2 3
输出
2
*/



/*
作者：toraoh
链接：https://www.nowcoder.com/discuss/28562
来源：牛客网

Prob B：不需要排序，只需要读入第一个数，
然后统计有多少个数>=第一个数，就知道排在倒数第几了。
至于能坚持几轮，最后一名肯定第1轮都过不去，
倒数第二名打倒数第一名能挺过去一轮，
倒数第3名的话也只能挺过去一轮——比他弱的2人，
一个被他打了，另一个肯定被别人打了，然后这个倒数第三名在下一轮直接出局了。
倒数第4名的话，能做到2轮，以此类推。
显然，n-1个和他一样的/比他弱的+他自己（共n个人），下一轮最多剩下floor(n/2)人。
那就尽量/2，除完之后结果>=1的次数，就是答案。
（或者说，这个排位的二进制表示的最高位，在哪一位。）
*/

#include <stdio.h>
int main()
{
    int n,f=-11111111,cnt=0,tmp;
    for(scanf("%d",&n);n--;){
        scanf("%d",&tmp);
        if(f==-11111111)
            f=tmp;
        if(tmp<=f)
            ++cnt;
    }
    int ans=0;
    while(cnt>1){
        cnt/=2;
        ++ans;
    }
    printf("%d\n",ans);
}