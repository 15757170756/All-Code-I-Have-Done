/*
腾讯校招的笔试题目：凑硬币
拼凑硬币：
时间限制：（每个case）2s 空间限制：128MB

小Q十分富有，拥有非常多的硬币，小Q拥有的硬币是有规律的，
对于所有的非负整数K,小Q恰好各有两个面值为2^K的硬币，
所以小Q拥有的硬币就是1,1,2,2,4,4,8,8，，，，，
小Q有一天去商店购买东西需要支付n元钱，
小Q想知道有多少中方案从他拥有的硬币中选取一些拼凑起来恰好是n元（
如果两种方案某个面值的硬币选取的个数不一样就考虑为不一样的方案）

输入：
输入包括一个整数n（1 <= n <= 10^18）,表示小 Q需要支付多少钱。注意n的范围。

输出：
输出一个整数，表示小Q可以拼凑出n元钱的方案数。

样例输入： 6
样例输出： 3


思路：如果每种币值的硬币只有一个，
那么这个数的二进制形式中1的个数就是唯一一种拼凑方法。
比如说6=110，也就是4+2；如果每个币值的硬币有两个，
那么可以用两个数来查找拼凑方法，比如6=4+2=3+3=5+1;但是要避免重复运算，
比如7=1+6=3+4，但是都是由1+2+4一种相同的方式组合而来的，
那么如何避免重复呢，经过发现，每一个组合（拼凑方法）的数的个数是不同的，
因此，可以用一个数组来记录个数为n的组合，如果已经组合过了
，就不重复计算。比如7=1+6=3+4，但是6=110一共有两个1,1有一个1,1+6一共有三个1，
因此是一种拼凑方法，但是3有两个1,4有一个1,3+4有2+1=3个1，因此不重复计算。
*/

#include <iostream>  
using namespace std;
#include<set>  
int main()
{
	long n, k, cnt = 0, t, p;
	set<long> s;///这个集合用来去重  
	cin >> n;
	long i, j;
	for (i = 0; i <= n / 2; ++i){
		j = n - i;
		p = ~(i^j);
		if (s.find(p) == s.end()){///如果这个凑法跟之前的不重复  
			s.insert(p);
			++cnt;
		}
	}
	cout << cnt << endl;
	return 0;
}