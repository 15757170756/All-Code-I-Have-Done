\hypertarget{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node}{}\section{Introduction\+To\+Algorithm\+:\+:Set\+Algorithm\+:\+:Disjoint\+Set\+Node$<$ K\+Type $>$ Struct Template Reference}
\label{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node}\index{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node$<$ K\+Type $>$@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node$<$ K\+Type $>$}}


Disjoint\+Set\+Node：不相交集合森林的节点，算法导论第21章21.3节  




{\ttfamily \#include $<$disjointset.\+h$>$}

\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef K\+Type \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a8f801679de129d80a99ad683430c534a}{Key\+Type}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a579c4ac62902b32c0bd04ccea02536ea}{Disjoint\+Set\+Node} (std\+::shared\+\_\+ptr$<$ \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a8f801679de129d80a99ad683430c534a}{Key\+Type} $>$v)
\begin{DoxyCompactList}\small\item\em Disjoint\+Set\+Node的显式构造函数 \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static std\+::shared\+\_\+ptr$<$ \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node}{Disjoint\+Set\+Node} $>$ \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a85fa0b8f80ba6529936ba2103c68194c}{find\+\_\+set} (std\+::shared\+\_\+ptr$<$ \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node}{Disjoint\+Set\+Node} $>$node)
\begin{DoxyCompactList}\small\item\em find\+\_\+set：返回结点所在集合的代表结点 \end{DoxyCompactList}\item 
static void \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a7346337c6f47bf066844c7101058cd92}{make\+\_\+set} (std\+::shared\+\_\+ptr$<$ \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node}{Disjoint\+Set\+Node} $>$node)
\begin{DoxyCompactList}\small\item\em make\+\_\+set：创建集合 \end{DoxyCompactList}\item 
static void \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_ac5fff2fa07d82ed04529aa9159d37efc}{link\+\_\+set} (std\+::shared\+\_\+ptr$<$ \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node}{Disjoint\+Set\+Node} $>$node\+X, std\+::shared\+\_\+ptr$<$ \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node}{Disjoint\+Set\+Node} $>$node\+Y)
\begin{DoxyCompactList}\small\item\em link\+\_\+set：链接集合 \end{DoxyCompactList}\item 
static void \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_aeb6281c8d6ec20987015fb1d1421b309}{union\+\_\+set} (std\+::shared\+\_\+ptr$<$ \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node}{Disjoint\+Set\+Node} $>$node\+X, std\+::shared\+\_\+ptr$<$ \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node}{Disjoint\+Set\+Node} $>$node\+Y)
\begin{DoxyCompactList}\small\item\em union\+\_\+set：合并集合 \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::weak\+\_\+ptr$<$ \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a8f801679de129d80a99ad683430c534a}{Key\+Type} $>$ \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_ae01535aa5e8ba05dceedd5c475d61c18}{value}
\item 
int \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a1fd137f74ca1317bfb02d9e1640ce147}{rank}
\item 
std\+::shared\+\_\+ptr$<$ \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node}{Disjoint\+Set\+Node} $>$ \hyperlink{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_ad5cf3f4d739ecd0c1f6d3b3005e21993}{parent}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename K\+Type$>$struct Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node$<$ K\+Type $>$}

Disjoint\+Set\+Node：不相交集合森林的节点，算法导论第21章21.3节 

一个不相交集合数据结构维护了一个不相交动态集的集合\{S1,S2,...Sk\}。我们用一个代表来标识每个集合，它是这个集合的某个成员。 不相交集合支持三个操作：（x,y等都是集合中的对象)


\begin{DoxyItemize}
\item make\+\_\+set(x)\+:建立一个新的集合，它的唯一成员是x
\item unionx(x,y)\+:将包含x和y的两个动态集合(表示为\+Sx和\+Sy)合并成一个新的集合。由于我们要求各个集合不相交，因此这里要消除原有的集合\+Sx和\+Sy。实际操作中， 我们把其中的一个集合的元素并入另一个集合中，来代替删除操作。
\item find\+\_\+set(x)\+:返回一个指针，该指针指向包含x的唯一集合的代表。
\end{DoxyItemize}

在某些图的算法中，图和不相交集数据结构的表示需要相互引用。即一个表示顶点的对象会包含一个指向与之对应的不相交集合对象的指针；反之亦然

不相交集合森林：不相交集合森林是不相交集合的一种更快的实现。用有根数来表示集合，树中的每个结点都包含一个成员，每棵树代表一个集合。 在不相交集合森林中，每个成员仅仅指向它的父节点。每棵树的根就是集合的代表并且它的父节点就是自己。

这里采用了启发式策略改进运行时间，使用了两种启发式策略：
\begin{DoxyItemize}
\item 按秩合并：每个结点x维持一个整数值属性rank,它代表了x的高度（从x到某一后代叶结点的最长简单路径上的结点数目）的一个上界。在按秩合并的union操作中， 我们让具有较小秩的根指向具有较大秩的根
\item 路径压缩：在{\ttfamily find\+\_\+set}操作中，使查找路径中的每个结点直接指向树根
\end{DoxyItemize}

如果单独采用按秩合并或者路径压缩，它们每一个都能改善不相交集合森林上操作的运行时间；而一起使用这两种启发式策略时，这种改善更大。 当同时使用按秩合并和路径压缩时，最坏情况下的运行时间为\+O(m$\ast$alpha$\ast$n))，这里alpha(n)是一个增长非常慢的函数。在任何一个可以想得到的不相交集合数据结构的应用中， alpha(n)$<$=4。其中n为结点个数，m为操作次数（运用了摊还分析） 

Definition at line 54 of file disjointset.\+h.



\subsection{Member Typedef Documentation}
\hypertarget{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a8f801679de129d80a99ad683430c534a}{}\index{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}!Key\+Type@{Key\+Type}}
\index{Key\+Type@{Key\+Type}!Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}}
\subsubsection[{Key\+Type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename K\+Type $>$ typedef K\+Type {\bf Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}$<$ K\+Type $>$\+::{\bf Key\+Type}}\label{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a8f801679de129d80a99ad683430c534a}
结点保存的数据类型 

Definition at line 56 of file disjointset.\+h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a579c4ac62902b32c0bd04ccea02536ea}{}\index{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}!Disjoint\+Set\+Node@{Disjoint\+Set\+Node}}
\index{Disjoint\+Set\+Node@{Disjoint\+Set\+Node}!Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}}
\subsubsection[{Disjoint\+Set\+Node(std\+::shared\+\_\+ptr$<$ Key\+Type $>$v)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename K\+Type $>$ {\bf Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}$<$ K\+Type $>$\+::{\bf Disjoint\+Set\+Node} (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ {\bf Key\+Type} $>$}]{v}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}\label{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a579c4ac62902b32c0bd04ccea02536ea}


Disjoint\+Set\+Node的显式构造函数 


\begin{DoxyParams}{Parameters}
{\em v\+:结点保存的数据的指针} & 将v存入结点的value中 \\
\hline
\end{DoxyParams}


Definition at line 65 of file disjointset.\+h.



\subsection{Member Function Documentation}
\hypertarget{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a85fa0b8f80ba6529936ba2103c68194c}{}\index{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}!find\+\_\+set@{find\+\_\+set}}
\index{find\+\_\+set@{find\+\_\+set}!Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}}
\subsubsection[{find\+\_\+set(std\+::shared\+\_\+ptr$<$ Disjoint\+Set\+Node $>$node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename K\+Type $>$ static std\+::shared\+\_\+ptr$<${\bf Disjoint\+Set\+Node}$>$ {\bf Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}$<$ K\+Type $>$\+::find\+\_\+set (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ {\bf Disjoint\+Set\+Node}$<$ K\+Type $>$ $>$}]{node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a85fa0b8f80ba6529936ba2103c68194c}


find\+\_\+set：返回结点所在集合的代表结点 


\begin{DoxyParams}{Parameters}
{\em node\+:要查找的结点。它必须非空，否则抛出异常} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: 结点所在集合的代表结点的强指针
\end{DoxyReturn}
该操作简单沿着指向父节点的指针找到树的根。树的根的特征是：它的父节点就是它本身。 若结点不在不相交集合森林中（当结点的父节点指针为空时），则抛出异常。

find\+\_\+set过程是一个 two\+\_\+pass method，当它递归时，第一趟沿着查找路径向上直到找到树根； 当递归回溯时，第二趟沿着搜索树向下更新每个节点，使其父节点直接指向树根 

Definition at line 84 of file disjointset.\+h.

\hypertarget{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_ac5fff2fa07d82ed04529aa9159d37efc}{}\index{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}!link\+\_\+set@{link\+\_\+set}}
\index{link\+\_\+set@{link\+\_\+set}!Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}}
\subsubsection[{link\+\_\+set(std\+::shared\+\_\+ptr$<$ Disjoint\+Set\+Node $>$node\+X, std\+::shared\+\_\+ptr$<$ Disjoint\+Set\+Node $>$node\+Y)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename K\+Type $>$ static void {\bf Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}$<$ K\+Type $>$\+::link\+\_\+set (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ {\bf Disjoint\+Set\+Node}$<$ K\+Type $>$ $>$}]{node\+X, }
\item[{std\+::shared\+\_\+ptr$<$ {\bf Disjoint\+Set\+Node}$<$ K\+Type $>$ $>$}]{node\+Y}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_ac5fff2fa07d82ed04529aa9159d37efc}


link\+\_\+set：链接集合 


\begin{DoxyParams}{Parameters}
{\em node\+X\+:待链接的第一个集合中的根节点。} & \\
\hline
{\em node\+Y\+:待合并的第二个集合中的根节点} & 每个结点x维持一个整数值属性rank,它代表了x的高度（从x到某一后代叶结点的最长简单路径上的结点数目）的一个上界。在链接时我们让具有较小秩的根指向具有较大秩的根.\\
\hline
\end{DoxyParams}

\begin{DoxyItemize}
\item 如果 node\+X或者node\+Y为空，则直接返回
\item 如果 node\+X 和 node\+Y非空，但是node\+X或者node\+Y不是根结点，抛出异常 
\end{DoxyItemize}

Definition at line 124 of file disjointset.\+h.

\hypertarget{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a7346337c6f47bf066844c7101058cd92}{}\index{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}!make\+\_\+set@{make\+\_\+set}}
\index{make\+\_\+set@{make\+\_\+set}!Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}}
\subsubsection[{make\+\_\+set(std\+::shared\+\_\+ptr$<$ Disjoint\+Set\+Node $>$node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename K\+Type $>$ static void {\bf Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}$<$ K\+Type $>$\+::make\+\_\+set (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ {\bf Disjoint\+Set\+Node}$<$ K\+Type $>$ $>$}]{node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a7346337c6f47bf066844c7101058cd92}


make\+\_\+set：创建集合 


\begin{DoxyParams}{Parameters}
{\em node\+:创建集合的结点。它必须非空，否则抛出异常} & 该操作简单地创建一棵只有一个结点的树。它将树根的秩设为0，将树根的父节点指向树根本身 \\
\hline
\end{DoxyParams}


Definition at line 100 of file disjointset.\+h.

\hypertarget{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_aeb6281c8d6ec20987015fb1d1421b309}{}\index{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}!union\+\_\+set@{union\+\_\+set}}
\index{union\+\_\+set@{union\+\_\+set}!Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}}
\subsubsection[{union\+\_\+set(std\+::shared\+\_\+ptr$<$ Disjoint\+Set\+Node $>$node\+X, std\+::shared\+\_\+ptr$<$ Disjoint\+Set\+Node $>$node\+Y)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename K\+Type $>$ static void {\bf Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}$<$ K\+Type $>$\+::union\+\_\+set (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ {\bf Disjoint\+Set\+Node}$<$ K\+Type $>$ $>$}]{node\+X, }
\item[{std\+::shared\+\_\+ptr$<$ {\bf Disjoint\+Set\+Node}$<$ K\+Type $>$ $>$}]{node\+Y}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_aeb6281c8d6ec20987015fb1d1421b309}


union\+\_\+set：合并集合 


\begin{DoxyParams}{Parameters}
{\em node\+X\+:待合并的第一个集合中的某个结点} & \\
\hline
{\em node\+Y\+:待合并的第二个集合中的某个结点} & 该操作首先获取每个结点所在集合的代表结点，然后将它们合并起来 \\
\hline
\end{DoxyParams}


Definition at line 151 of file disjointset.\+h.



\subsection{Member Data Documentation}
\hypertarget{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_ad5cf3f4d739ecd0c1f6d3b3005e21993}{}\index{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}!parent@{parent}}
\index{parent@{parent}!Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}}
\subsubsection[{parent}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename K\+Type $>$ std\+::shared\+\_\+ptr$<${\bf Disjoint\+Set\+Node}$>$ {\bf Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}$<$ K\+Type $>$\+::parent}\label{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_ad5cf3f4d739ecd0c1f6d3b3005e21993}
结点的父指针 

Definition at line 69 of file disjointset.\+h.

\hypertarget{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a1fd137f74ca1317bfb02d9e1640ce147}{}\index{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}!rank@{rank}}
\index{rank@{rank}!Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}}
\subsubsection[{rank}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename K\+Type $>$ int {\bf Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}$<$ K\+Type $>$\+::rank}\label{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_a1fd137f74ca1317bfb02d9e1640ce147}
结点的秩 

Definition at line 68 of file disjointset.\+h.

\hypertarget{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_ae01535aa5e8ba05dceedd5c475d61c18}{}\index{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}!value@{value}}
\index{value@{value}!Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node@{Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}}
\subsubsection[{value}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename K\+Type $>$ std\+::weak\+\_\+ptr$<${\bf Key\+Type}$>$ {\bf Introduction\+To\+Algorithm\+::\+Set\+Algorithm\+::\+Disjoint\+Set\+Node}$<$ K\+Type $>$\+::value}\label{struct_introduction_to_algorithm_1_1_set_algorithm_1_1_disjoint_set_node_ae01535aa5e8ba05dceedd5c475d61c18}
结点保存的数据的弱指针 

Definition at line 67 of file disjointset.\+h.



The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/set\+\_\+algorithms/disjoint\+\_\+set/\hyperlink{disjointset_8h}{disjointset.\+h}\end{DoxyCompactItemize}
