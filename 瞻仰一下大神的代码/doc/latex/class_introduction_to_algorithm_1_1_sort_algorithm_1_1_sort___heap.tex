\hypertarget{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap}{}\section{Introduction\+To\+Algorithm\+:\+:Sort\+Algorithm\+:\+:Sort\+\_\+\+Heap$<$ Iterator, Compare\+Type $>$ Class Template Reference}
\label{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap}\index{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap$<$ Iterator, Compare\+Type $>$@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap$<$ Iterator, Compare\+Type $>$}}


Sort\+\_\+\+Heap：用于堆排序的堆，算法导论第6章  




{\ttfamily \#include $<$heapsort.\+h$>$}

\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::iterator\+\_\+traits$<$ Iterator $>$\+::value\+\_\+type \hyperlink{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a5af910656f5d3c65d47f992dbf380c61}{T}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_adfaf638a6fd27c6295f7ac0a07484a00}{operator()} (const Iterator from, std\+::size\+\_\+t size, Compare\+Type compare=Compare\+Type())
\begin{DoxyCompactList}\small\item\em operator() \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a64c05fac6da6e6e0d63e733640d0cf97}{\+\_\+setup\+Heap} (Compare\+Type compare=Compare\+Type())
\begin{DoxyCompactList}\small\item\em \+\_\+setup\+Heap\+:建堆 \end{DoxyCompactList}\item 
void \hyperlink{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a0535910130c6c750faf7801059e4a9fa}{\+\_\+heapify} (std\+::size\+\_\+t element\+Index, Compare\+Type compare=Compare\+Type())
\begin{DoxyCompactList}\small\item\em \+\_\+heapify：维持堆性质 \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a72f5fa2e41901a80fdb9a3bcece8a33f}{\+\_\+parent\+Index} (std\+::size\+\_\+t element\+Index, bool \&valid)
\begin{DoxyCompactList}\small\item\em \+\_\+parent\+Index\+:返回一个节点的父节点位置 \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_af4033a3e0cd7dab78cb1081f3dece165}{\+\_\+lchild\+Index} (std\+::size\+\_\+t element\+Index, bool \&valid)
\begin{DoxyCompactList}\small\item\em \+\_\+lchild\+Index\+:返回一个节点的左子节点位置 \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a71532dbfd31fdb854aa46dbca6e411ac}{\+\_\+rchild\+Index} (std\+::size\+\_\+t element\+Index, bool \&valid)
\begin{DoxyCompactList}\small\item\em \+\_\+rchild\+Index\+:返回一个节点的右子节点位置 \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
Iterator \hyperlink{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a484d28581bfe39a387d90852e38ac36c}{\+\_\+from}
\item 
std\+::size\+\_\+t \hyperlink{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a57a42830d3b52d60d2ec1dfd11e2bda6}{\+\_\+size}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Iterator, typename Compare\+Type = std\+::less$<$typename std\+::iterator\+\_\+traits$<$\+Iterator$>$\+::value\+\_\+type$>$$>$class Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap$<$ Iterator, Compare\+Type $>$}

Sort\+\_\+\+Heap：用于堆排序的堆，算法导论第6章 


\begin{DoxyItemize}
\item 堆排序思想：假设对数组\+A\mbox{[}p...r\mbox{]}排序：首先将数组构建成一个最大堆（或者最小堆，这里的实现采用最大堆）。然后第一个元素就是堆中最大的元素。 将第一个元素与最后一个元素交换，同时堆的规模缩减1，再将堆维持最大堆性质。不断循环最后得到一个排序好的序列
\item 时间复杂度 O(nlogn)
\item 原地排序
\end{DoxyItemize}

堆排序有两个重要操作：


\begin{DoxyItemize}
\item heapify(index)操作：维持以index为根节点的子堆的性质。它比较index与其左右子节点的值，选取其最大的那个提升到index节点上。同时递归向下。具体见\+\_\+heapify()方法说明
\item setup\+Heap()操作： 建堆操作。它从堆的最低层向上层反复调用heapify操作进行建堆。 
\end{DoxyItemize}

Definition at line 40 of file heapsort.\+h.



\subsection{Member Typedef Documentation}
\hypertarget{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a5af910656f5d3c65d47f992dbf380c61}{}\index{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}!T@{T}}
\index{T@{T}!Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}}
\subsubsection[{T}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Iterator, typename Compare\+Type = std\+::less$<$typename std\+::iterator\+\_\+traits$<$\+Iterator$>$\+::value\+\_\+type$>$$>$ typedef std\+::iterator\+\_\+traits$<$Iterator$>$\+::value\+\_\+type {\bf Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}$<$ Iterator, Compare\+Type $>$\+::{\bf T}}\label{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a5af910656f5d3c65d47f992dbf380c61}
迭代器指向对象的值类型 

Definition at line 43 of file heapsort.\+h.



\subsection{Member Function Documentation}
\hypertarget{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a0535910130c6c750faf7801059e4a9fa}{}\index{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}!\+\_\+heapify@{\+\_\+heapify}}
\index{\+\_\+heapify@{\+\_\+heapify}!Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}}
\subsubsection[{\+\_\+heapify(std\+::size\+\_\+t element\+Index, Compare\+Type compare=\+Compare\+Type())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Iterator, typename Compare\+Type = std\+::less$<$typename std\+::iterator\+\_\+traits$<$\+Iterator$>$\+::value\+\_\+type$>$$>$ void {\bf Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}$<$ Iterator, Compare\+Type $>$\+::\+\_\+heapify (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{element\+Index, }
\item[{Compare\+Type}]{compare = {\ttfamily CompareType()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a0535910130c6c750faf7801059e4a9fa}


\+\_\+heapify：维持堆性质 


\begin{DoxyParams}{Parameters}
{\em element\+Index} & \+: 要维持以该节点为根节点的子堆的堆性质 \\
\hline
{\em compare} & 一个可调用对象，可用于比较两个对象的小于比较，默认为std\+::less$<$\+T$>$ \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void
\end{DoxyReturn}
首先调用比较该节点与左右子节点的最大值。如果最大值为它本身，则维持了性质，返回；如果最大值不是它本身，那么必然为左、右子节点之一。 将该最大节点（假设为左子节点）交换到根节点，然后以左子节点递归调用heapify操作


\begin{DoxyItemize}
\item 时间复杂度 O(n)
\item 原地操作 
\end{DoxyItemize}

Definition at line 102 of file heapsort.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_af4033a3e0cd7dab78cb1081f3dece165}{}\index{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}!\+\_\+lchild\+Index@{\+\_\+lchild\+Index}}
\index{\+\_\+lchild\+Index@{\+\_\+lchild\+Index}!Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}}
\subsubsection[{\+\_\+lchild\+Index(std\+::size\+\_\+t element\+Index, bool \&valid)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Iterator, typename Compare\+Type = std\+::less$<$typename std\+::iterator\+\_\+traits$<$\+Iterator$>$\+::value\+\_\+type$>$$>$ std\+::size\+\_\+t {\bf Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}$<$ Iterator, Compare\+Type $>$\+::\+\_\+lchild\+Index (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{element\+Index, }
\item[{bool \&}]{valid}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_af4033a3e0cd7dab78cb1081f3dece165}


\+\_\+lchild\+Index\+:返回一个节点的左子节点位置 


\begin{DoxyParams}{Parameters}
{\em element\+Index} & \+: 节点位置 \\
\hline
{\em valid} & 一个bool\&值，用于返回，指示子节点是否有效 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
左子节点位置(std\+::size\+\_\+t)
\end{DoxyReturn}
根据最大堆的性质，一个节点element\+Index的左子节点是它的位置(element\+Index/2)+1


\begin{DoxyItemize}
\item 当最大堆大小为0、1时，它没有左子节点，左子节点无效
\item 当左子节点超过堆大小时，它无效 
\end{DoxyItemize}

Definition at line 162 of file heapsort.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a72f5fa2e41901a80fdb9a3bcece8a33f}{}\index{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}!\+\_\+parent\+Index@{\+\_\+parent\+Index}}
\index{\+\_\+parent\+Index@{\+\_\+parent\+Index}!Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}}
\subsubsection[{\+\_\+parent\+Index(std\+::size\+\_\+t element\+Index, bool \&valid)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Iterator, typename Compare\+Type = std\+::less$<$typename std\+::iterator\+\_\+traits$<$\+Iterator$>$\+::value\+\_\+type$>$$>$ std\+::size\+\_\+t {\bf Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}$<$ Iterator, Compare\+Type $>$\+::\+\_\+parent\+Index (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{element\+Index, }
\item[{bool \&}]{valid}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a72f5fa2e41901a80fdb9a3bcece8a33f}


\+\_\+parent\+Index\+:返回一个节点的父节点位置 


\begin{DoxyParams}{Parameters}
{\em element\+Index} & \+: 子节点位置 \\
\hline
{\em valid} & 一个bool\&值，用于返回，指示父节点是否有效 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
父节点位置(std\+::size\+\_\+t)
\end{DoxyReturn}
根据最大堆的性质，一个子节点element\+Index的父节点是它的位置(element\+Index-\/1)/2。


\begin{DoxyItemize}
\item 超出堆大小的节点，其父节点无效 
\end{DoxyItemize}

Definition at line 139 of file heapsort.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a71532dbfd31fdb854aa46dbca6e411ac}{}\index{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}!\+\_\+rchild\+Index@{\+\_\+rchild\+Index}}
\index{\+\_\+rchild\+Index@{\+\_\+rchild\+Index}!Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}}
\subsubsection[{\+\_\+rchild\+Index(std\+::size\+\_\+t element\+Index, bool \&valid)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Iterator, typename Compare\+Type = std\+::less$<$typename std\+::iterator\+\_\+traits$<$\+Iterator$>$\+::value\+\_\+type$>$$>$ std\+::size\+\_\+t {\bf Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}$<$ Iterator, Compare\+Type $>$\+::\+\_\+rchild\+Index (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{element\+Index, }
\item[{bool \&}]{valid}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a71532dbfd31fdb854aa46dbca6e411ac}


\+\_\+rchild\+Index\+:返回一个节点的右子节点位置 


\begin{DoxyParams}{Parameters}
{\em element\+Index} & \+: 节点位置 \\
\hline
{\em valid} & 一个bool\&值，用于返回，指示子节点是否有效 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
右子节点位置(std\+::size\+\_\+t)
\end{DoxyReturn}
根据最大堆的性质，一个节点element\+Index的右子节点是它的位置(element\+Index/2)+2


\begin{DoxyItemize}
\item 当最大堆大小为0、、1、2时，它没有右子节点，右子节点无效
\item 当右子节点超过堆大小时，它无效 
\end{DoxyItemize}

Definition at line 190 of file heapsort.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a64c05fac6da6e6e0d63e733640d0cf97}{}\index{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}!\+\_\+setup\+Heap@{\+\_\+setup\+Heap}}
\index{\+\_\+setup\+Heap@{\+\_\+setup\+Heap}!Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}}
\subsubsection[{\+\_\+setup\+Heap(\+Compare\+Type compare=\+Compare\+Type())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Iterator, typename Compare\+Type = std\+::less$<$typename std\+::iterator\+\_\+traits$<$\+Iterator$>$\+::value\+\_\+type$>$$>$ void {\bf Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}$<$ Iterator, Compare\+Type $>$\+::\+\_\+setup\+Heap (
\begin{DoxyParamCaption}
\item[{Compare\+Type}]{compare = {\ttfamily CompareType()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a64c05fac6da6e6e0d63e733640d0cf97}


\+\_\+setup\+Heap\+:建堆 


\begin{DoxyParams}{Parameters}
{\em compare} & 一个可调用对象，可用于比较两个对象的小于比较，默认为std\+::less$<$\+T$>$ \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void
\end{DoxyReturn}
从后一半的元素开始依次向前调用heapify操作（根据最大堆性质，除了最底层它是完全充满的）


\begin{DoxyItemize}
\item 时间复杂度 O(nlogn)
\item 原地操作 
\end{DoxyItemize}

Definition at line 79 of file heapsort.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_adfaf638a6fd27c6295f7ac0a07484a00}{}\index{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}!operator()@{operator()}}
\index{operator()@{operator()}!Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}}
\subsubsection[{operator()(const Iterator from, std\+::size\+\_\+t size, Compare\+Type compare=\+Compare\+Type())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Iterator, typename Compare\+Type = std\+::less$<$typename std\+::iterator\+\_\+traits$<$\+Iterator$>$\+::value\+\_\+type$>$$>$ void {\bf Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}$<$ Iterator, Compare\+Type $>$\+::operator() (
\begin{DoxyParamCaption}
\item[{const Iterator}]{from, }
\item[{std\+::size\+\_\+t}]{size, }
\item[{Compare\+Type}]{compare = {\ttfamily CompareType()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_adfaf638a6fd27c6295f7ac0a07484a00}


operator() 


\begin{DoxyParams}{Parameters}
{\em from} & \+: 待排序序列的起始迭代器（也可以是指向数组中某元素的指针） \\
\hline
{\em size} & 待排序序列的长度 \\
\hline
{\em compare} & 一个可调用对象，可用于比较两个对象的小于比较，默认为std\+::less$<$\+T$>$ \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void
\end{DoxyReturn}
首先调用 \hyperlink{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a64c05fac6da6e6e0d63e733640d0cf97}{\+\_\+setup\+Heap()}建堆。然后再反复抽取最大值到堆尾部，然后维持堆的性质。


\begin{DoxyItemize}
\item 时间复杂度 O(nlogn)
\item 原地排序 
\end{DoxyItemize}

Definition at line 56 of file heapsort.\+h.



\subsection{Member Data Documentation}
\hypertarget{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a484d28581bfe39a387d90852e38ac36c}{}\index{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}!\+\_\+from@{\+\_\+from}}
\index{\+\_\+from@{\+\_\+from}!Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}}
\subsubsection[{\+\_\+from}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Iterator, typename Compare\+Type = std\+::less$<$typename std\+::iterator\+\_\+traits$<$\+Iterator$>$\+::value\+\_\+type$>$$>$ Iterator {\bf Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}$<$ Iterator, Compare\+Type $>$\+::\+\_\+from\hspace{0.3cm}{\ttfamily [private]}}\label{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a484d28581bfe39a387d90852e38ac36c}
堆根节点位置 

Definition at line 206 of file heapsort.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a57a42830d3b52d60d2ec1dfd11e2bda6}{}\index{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}!\+\_\+size@{\+\_\+size}}
\index{\+\_\+size@{\+\_\+size}!Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap@{Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}}
\subsubsection[{\+\_\+size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Iterator, typename Compare\+Type = std\+::less$<$typename std\+::iterator\+\_\+traits$<$\+Iterator$>$\+::value\+\_\+type$>$$>$ std\+::size\+\_\+t {\bf Introduction\+To\+Algorithm\+::\+Sort\+Algorithm\+::\+Sort\+\_\+\+Heap}$<$ Iterator, Compare\+Type $>$\+::\+\_\+size\hspace{0.3cm}{\ttfamily [private]}}\label{class_introduction_to_algorithm_1_1_sort_algorithm_1_1_sort___heap_a57a42830d3b52d60d2ec1dfd11e2bda6}
堆大小 

Definition at line 207 of file heapsort.\+h.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/sort\+\_\+algorithms/heap\+\_\+sort/\hyperlink{heapsort_8h}{heapsort.\+h}\end{DoxyCompactItemize}
