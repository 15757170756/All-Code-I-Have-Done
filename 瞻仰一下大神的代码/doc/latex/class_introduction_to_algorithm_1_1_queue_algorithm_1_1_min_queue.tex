\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue}{}\section{Introduction\+To\+Algorithm\+:\+:Queue\+Algorithm\+:\+:Min\+Queue$<$ T, T\+Key\+Type $>$ Class Template Reference}
\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue$<$ T, T\+Key\+Type $>$@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue$<$ T, T\+Key\+Type $>$}}


Min\+Queue：最小优先级队列，算法导论第6章6.5节  




{\ttfamily \#include $<$minqueue.\+h$>$}

\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::function$<$ bool(std\+::shared\+\_\+ptr$<$ T $>$, std\+::shared\+\_\+ptr$<$ T $>$)$>$ \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a8f2f5b5d2b7097bbc6edda7b9c9228a6}{Compare\+Type}
\item 
typedef std\+::function$<$ T\+Key\+Type \&(std\+::shared\+\_\+ptr$<$ T $>$)$>$ \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a391cb754ab172d1d4cdefd34130b917c}{Get\+Key\+Type}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a98e54e4e2c19918032b09e23e79a25e5}{Min\+Queue} (\hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a8f2f5b5d2b7097bbc6edda7b9c9228a6}{Compare\+Type} compare, \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a391cb754ab172d1d4cdefd34130b917c}{Get\+Key\+Type} get\+Key)
\begin{DoxyCompactList}\small\item\em 显式构造函数 \end{DoxyCompactList}\item 
\hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a770243b2227a15bdc2105dde6549c745}{Min\+Queue} (std\+::size\+\_\+t reseve\+\_\+size, \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a8f2f5b5d2b7097bbc6edda7b9c9228a6}{Compare\+Type} compare, \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a391cb754ab172d1d4cdefd34130b917c}{Get\+Key\+Type} get\+Key)
\begin{DoxyCompactList}\small\item\em 显式构造函数 \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ T $>$ \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a96293074ee6adef713e9e47059958ea2}{min} ()
\begin{DoxyCompactList}\small\item\em min\+:返回最小值 \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ T $>$ \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a71022b9e1e9993ec5c5876da9e6e6eee}{extract\+\_\+min} ()
\begin{DoxyCompactList}\small\item\em extract\+\_\+min\+:删除队列中最小值，并返回最小值 \end{DoxyCompactList}\item 
int \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a0992696959d7300082654529becd1765}{insert} (std\+::shared\+\_\+ptr$<$ T $>$ element)
\begin{DoxyCompactList}\small\item\em insert\+:向队列中插入一个元素 \end{DoxyCompactList}\item 
bool \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a1b484baf6cd011a4b91aa77a644e5a44}{is\+\_\+empty} ()
\begin{DoxyCompactList}\small\item\em is\+\_\+empty\+:返回队列是否为空 \end{DoxyCompactList}\item 
int \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a545dbdb76e0b6e9c4227e558ab9b1239}{index\+\_\+inqueue} (std\+::shared\+\_\+ptr$<$ T $>$ element)
\begin{DoxyCompactList}\small\item\em is\+\_\+inqueue\+:返回指定元素是否在队列中 \end{DoxyCompactList}\item 
void \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_aa934049abcfedd59fa9ffe6d91fea30c}{decreate\+\_\+key} (std\+::size\+\_\+t element\+\_\+index, T\+Key\+Type new\+\_\+key)
\begin{DoxyCompactList}\small\item\em decreate\+\_\+key\+:缩减队列中某个元素的{\ttfamily key} \end{DoxyCompactList}\item 
void \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a9a432c7c167a4f9a56c2988cfdc04620}{setup\+Heap} ()
\begin{DoxyCompactList}\small\item\em setup\+Heap\+:建堆 \end{DoxyCompactList}\item 
void \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a4ddfab80f781d5b5f7544164bf266f82}{heapify} (std\+::size\+\_\+t element\+Index)
\begin{DoxyCompactList}\small\item\em heapify：维持堆性质 \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
std\+::size\+\_\+t \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a3b7cac401c8cf45806e61aad3799eda0}{\+\_\+parent\+Index} (std\+::size\+\_\+t element\+Index, bool \&valid)
\begin{DoxyCompactList}\small\item\em \+\_\+parent\+Index\+:返回一个节点的父节点位置 \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a0d2a517cd63fc33c0403a4d4c83c7e9d}{\+\_\+lchild\+Index} (std\+::size\+\_\+t element\+Index, bool \&valid)
\begin{DoxyCompactList}\small\item\em \+\_\+lchild\+Index\+:返回一个节点的左子节点位置 \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a7129becd0fd74b5d2c17702e65f32300}{\+\_\+rchild\+Index} (std\+::size\+\_\+t element\+Index, bool \&valid)
\begin{DoxyCompactList}\small\item\em \+\_\+rchild\+Index\+:返回一个节点的右子节点位置 \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ std\+::shared\+\_\+ptr$<$ T $>$ $>$ \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_ad463395cef741624e6d078e4e4fc624f}{\+\_\+data}
\item 
std\+::size\+\_\+t \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a0de92802e37516dda2c01de776aba641}{\+\_\+size}
\item 
\hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a8f2f5b5d2b7097bbc6edda7b9c9228a6}{Compare\+Type} \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a5de60762d317fc92c18e882dd50f8dfa}{\+\_\+compare}
\item 
\hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a391cb754ab172d1d4cdefd34130b917c}{Get\+Key\+Type} \hyperlink{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a3f791f9dd9d61dc2caf1d6b2b354f4c4}{\+\_\+get\+Key}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename T, typename T\+Key\+Type$>$class Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue$<$ T, T\+Key\+Type $>$}

Min\+Queue：最小优先级队列，算法导论第6章6.5节 

优先级队列是一种用来维护由一组元素构成集合\+S的数据结构，其中每个元素都有一个相关的值，称之为关键字。一个最小优先级队列支持以下操作：


\begin{DoxyItemize}
\item insert(\+S,x)\+:将元素x插入到集合\+S中。
\item min(\+S)\+:返回\+S中具有最小关键字的元素
\item extract\+\_\+min(\+S)\+:去掉并返回\+S中具有最小关键字的元素
\item decrease\+\_\+key(\+S,x,k)\+:将元素x的关键字值减小到k,这里要求k的值小于x的原始关键字
\end{DoxyItemize}

本算法的实现时，有以下几种变化：


\begin{DoxyItemize}
\item 增加了以下的接口：
\begin{DoxyItemize}
\item is\+\_\+empty(\+S)\+: 返回\+S是否为空
\item is\+\_\+inqueue(\+S,x)\+:判断元素x是否在\+S中
\item setup\+Heap(\+S)\+:建立最小堆（由堆的接口遗留而来)
\item heapify(\+S,index)\+:操作堆的指定结点使得它符合最小堆条件（由堆的接口遗留下来）
\end{DoxyItemize}
\item 增加了队列容量属性。队列容量由{\ttfamily \+\_\+data}的大小来表征。默认将{\ttfamily \+\_\+data}大小设为0；可以显式提供{\ttfamily reseve\+\_\+size}参数来设置{\ttfamily \+\_\+data}的大小。 队列容量用于限制队列大小。一旦队列已满，则下一次插入之前会将队列容量增加一倍；一旦队列不足队列的1/4，则一旦执行{\ttfamily extract\+\_\+min}操作则将队列容量缩减至一半
\item 增加了两个特殊的可调用对象，这两个方法的引入使得最小优先级队列不仅可以应用于class和struct类型，也可以应用于int,double等非类的类型
\begin{DoxyItemize}
\item \+\_\+get\+Key\+:是一个std\+:\+:function$<$T\+Key\+Type\&(std\+::shared\+\_\+ptr$<$\+T$>$)$>$类型的对象，它可以接收std\+::shared\+\_\+ptr$<$\+T$>$类型的参数，返回\+T\+Key\+Type类型的引用。 其中队列保存的是\+T类型数据的强引用，\+T\+Key\+Type是\+T类型数据的关键字类型。通过\+\_\+get\+Key可以获取队列数据的关键字的引用。
\begin{DoxyItemize}
\item 对于class类型，\+T\+Key\+Type就是\+T对象的关键字类型，\+\_\+get\+Key就是返回关键字的引用
\item 对于int等内置类型，\+T\+Key\+Type就是\+T本身。\+\_\+get\+Key就是返回它自身的引用
\end{DoxyItemize}
\item \+\_\+compare\+:是一个std\+:\+:function$<$bool (std\+::shared\+\_\+ptr$<$\+T$>$,std\+::shared\+\_\+ptr$<$\+T$>$)$>$类型的对象，它用于队列中两个数据的大小比较。 
\end{DoxyItemize}
\end{DoxyItemize}

Definition at line 60 of file minqueue.\+h.



\subsection{Member Typedef Documentation}
\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a8f2f5b5d2b7097bbc6edda7b9c9228a6}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!Compare\+Type@{Compare\+Type}}
\index{Compare\+Type@{Compare\+Type}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{Compare\+Type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ typedef std\+::function$<$bool (std\+::shared\+\_\+ptr$<$T$>$,std\+::shared\+\_\+ptr$<$T$>$)$>$ {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::{\bf Compare\+Type}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a8f2f5b5d2b7097bbc6edda7b9c9228a6}
一个可调用对象类型，该类型的对象可用于比较两个std\+::shared\+\_\+ptr$<$\+T$>$的小于比较 

Definition at line 63 of file minqueue.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a391cb754ab172d1d4cdefd34130b917c}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!Get\+Key\+Type@{Get\+Key\+Type}}
\index{Get\+Key\+Type@{Get\+Key\+Type}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{Get\+Key\+Type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ typedef std\+::function$<$T\+Key\+Type\&(std\+::shared\+\_\+ptr$<$T$>$)$>$ {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::{\bf Get\+Key\+Type}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a391cb754ab172d1d4cdefd34130b917c}
一个可调用对象，该类型的对象可用于获取std\+::shared\+\_\+ptr$<$\+T$>$的关键字，并修改该关键字（返回的是关键字的引用） 

Definition at line 64 of file minqueue.\+h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a98e54e4e2c19918032b09e23e79a25e5}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!Min\+Queue@{Min\+Queue}}
\index{Min\+Queue@{Min\+Queue}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{Min\+Queue(\+Compare\+Type compare, Get\+Key\+Type get\+Key)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::{\bf Min\+Queue} (
\begin{DoxyParamCaption}
\item[{{\bf Compare\+Type}}]{compare, }
\item[{{\bf Get\+Key\+Type}}]{get\+Key}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a98e54e4e2c19918032b09e23e79a25e5}


显式构造函数 


\begin{DoxyParams}{Parameters}
{\em compare\+:一个可调用对象，可用于比较两个std\+::shared\+\_\+ptr$<$\+T$>$对象的小于比较} & \\
\hline
{\em get\+Key：一个可调用对象，它的参数为std\+::shared\+\_\+ptr$<$\+T$>$，返回\+T\+Key\&。通过它的返回值可以获取\+T的key，也可以修改\+T的key} & \\
\hline
\end{DoxyParams}


Definition at line 71 of file minqueue.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a770243b2227a15bdc2105dde6549c745}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!Min\+Queue@{Min\+Queue}}
\index{Min\+Queue@{Min\+Queue}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{Min\+Queue(std\+::size\+\_\+t reseve\+\_\+size, Compare\+Type compare, Get\+Key\+Type get\+Key)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::{\bf Min\+Queue} (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{reseve\+\_\+size, }
\item[{{\bf Compare\+Type}}]{compare, }
\item[{{\bf Get\+Key\+Type}}]{get\+Key}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a770243b2227a15bdc2105dde6549c745}


显式构造函数 


\begin{DoxyParams}{Parameters}
{\em reseve\+\_\+size\+:指定队列的初始容量} & \\
\hline
{\em compare\+:一个可调用对象，可用于比较两个std\+::shared\+\_\+ptr$<$\+T$>$对象的小于比较} & \\
\hline
{\em get\+Key：一个可调用对象，它的参数为std\+::shared\+\_\+ptr$<$\+T$>$，返回\+T\+Key\&。通过它的返回值可以获取\+T的key，也可以修改\+T的key} & \\
\hline
\end{DoxyParams}


Definition at line 79 of file minqueue.\+h.



\subsection{Member Function Documentation}
\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a0d2a517cd63fc33c0403a4d4c83c7e9d}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!\+\_\+lchild\+Index@{\+\_\+lchild\+Index}}
\index{\+\_\+lchild\+Index@{\+\_\+lchild\+Index}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{\+\_\+lchild\+Index(std\+::size\+\_\+t element\+Index, bool \&valid)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ std\+::size\+\_\+t {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::\+\_\+lchild\+Index (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{element\+Index, }
\item[{bool \&}]{valid}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a0d2a517cd63fc33c0403a4d4c83c7e9d}


\+\_\+lchild\+Index\+:返回一个节点的左子节点位置 


\begin{DoxyParams}{Parameters}
{\em element\+Index} & \+: 节点位置 \\
\hline
{\em valid} & 一个bool\&值，用于返回，指示子节点是否有效 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
左子节点位置(std\+::size\+\_\+t)
\end{DoxyReturn}
根据最小堆的性质，一个节点element\+Index的左子节点是它的位置(element\+Index/2)+1


\begin{DoxyItemize}
\item 当最小堆大小为0、1时，它没有左子节点，左子节点无效
\item 当左子节点超过堆大小时，它无效 
\end{DoxyItemize}

Definition at line 326 of file minqueue.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a3b7cac401c8cf45806e61aad3799eda0}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!\+\_\+parent\+Index@{\+\_\+parent\+Index}}
\index{\+\_\+parent\+Index@{\+\_\+parent\+Index}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{\+\_\+parent\+Index(std\+::size\+\_\+t element\+Index, bool \&valid)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ std\+::size\+\_\+t {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::\+\_\+parent\+Index (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{element\+Index, }
\item[{bool \&}]{valid}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a3b7cac401c8cf45806e61aad3799eda0}


\+\_\+parent\+Index\+:返回一个节点的父节点位置 


\begin{DoxyParams}{Parameters}
{\em element\+Index} & \+: 子节点位置 \\
\hline
{\em valid} & 一个bool\&值，用于返回，指示父节点是否有效 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
父节点位置(std\+::size\+\_\+t)
\end{DoxyReturn}
根据最小堆的性质，一个子节点element\+Index的父节点是它的位置(element\+Index-\/1)/2。


\begin{DoxyItemize}
\item 超出堆大小的节点，其父节点无效 
\end{DoxyItemize}

Definition at line 303 of file minqueue.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a7129becd0fd74b5d2c17702e65f32300}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!\+\_\+rchild\+Index@{\+\_\+rchild\+Index}}
\index{\+\_\+rchild\+Index@{\+\_\+rchild\+Index}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{\+\_\+rchild\+Index(std\+::size\+\_\+t element\+Index, bool \&valid)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ std\+::size\+\_\+t {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::\+\_\+rchild\+Index (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{element\+Index, }
\item[{bool \&}]{valid}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a7129becd0fd74b5d2c17702e65f32300}


\+\_\+rchild\+Index\+:返回一个节点的右子节点位置 


\begin{DoxyParams}{Parameters}
{\em element\+Index} & \+: 节点位置 \\
\hline
{\em valid} & 一个bool\&值，用于返回，指示子节点是否有效 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
右子节点位置(std\+::size\+\_\+t)
\end{DoxyReturn}
根据最小堆的性质，一个节点element\+Index的右子节点是它的位置(element\+Index/2)+2


\begin{DoxyItemize}
\item 当最小堆大小为0、、1、2时，它没有右子节点，右子节点无效
\item 当右子节点超过堆大小时，它无效 
\end{DoxyItemize}

Definition at line 353 of file minqueue.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_aa934049abcfedd59fa9ffe6d91fea30c}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!decreate\+\_\+key@{decreate\+\_\+key}}
\index{decreate\+\_\+key@{decreate\+\_\+key}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{decreate\+\_\+key(std\+::size\+\_\+t element\+\_\+index, T\+Key\+Type new\+\_\+key)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ void {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::decreate\+\_\+key (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{element\+\_\+index, }
\item[{T\+Key\+Type}]{new\+\_\+key}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_aa934049abcfedd59fa9ffe6d91fea30c}


decreate\+\_\+key\+:缩减队列中某个元素的{\ttfamily key} 


\begin{DoxyParams}{Parameters}
{\em element\+\_\+index} & 待缩减元素的下标 \\
\hline
{\em new\+\_\+key：待缩减元素的新$<$tt$>$key$<$/tt$>$，类型为\+T\+Key} & 缩减之前先判断缩减是否有效，若无效则抛出异常。\\
\hline
\end{DoxyParams}

\begin{DoxyItemize}
\item 若{\ttfamily element\+\_\+index}超过了队列大小，则抛出异常
\item 若{\ttfamily new\+\_\+key}大于等于待缩减元素的{\ttfamily key}，则抛出异常
\end{DoxyItemize}

缩减过程为：


\begin{DoxyItemize}
\item 将待缩减元素的{\ttfamily key}赋值为新值
\item 不断的将该元素向父节点比较：
\begin{DoxyItemize}
\item 若父节点较小，则终止比较过程
\item 若父节点较大，则交换当前节点与父节点，并将当前节点指向父节点进行下一轮比较
\item 若当前节点已经是队列首个元素，则终止比较过程
\end{DoxyItemize}
\item 时间复杂度 O(h)
\item 原地操作 
\end{DoxyItemize}

Definition at line 216 of file minqueue.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a71022b9e1e9993ec5c5876da9e6e6eee}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!extract\+\_\+min@{extract\+\_\+min}}
\index{extract\+\_\+min@{extract\+\_\+min}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{extract\+\_\+min()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ std\+::shared\+\_\+ptr$<$T$>$ {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::extract\+\_\+min (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a71022b9e1e9993ec5c5876da9e6e6eee}


extract\+\_\+min\+:删除队列中最小值，并返回最小值 

\begin{DoxyReturn}{Returns}
最小值的强引用
\end{DoxyReturn}
根据最小堆的性质，队列的第一个值就是最小值的强引用。


\begin{DoxyItemize}
\item 如果队列为空，则返回一个空引用
\item 如果队列非空，则执行以下操作：
\begin{DoxyItemize}
\item 交换队列的第一个元素和最后一个元素
\item 队列的{\ttfamily \+\_\+size}自减
\item 此时队列的首个元素违反了最小堆性质，因此执行{\ttfamily heapify(0)}保持性质
\item 返回旧的首个元素
\end{DoxyItemize}
\end{DoxyItemize}

一旦队列长度不足容量的1/4，则将队列容量设置为队列长度的一倍（为了防止极端情况，如\+\_\+size=0，此时将队列容量设为队列长度的一倍加上2）


\begin{DoxyItemize}
\item 时间复杂度 O(h),h为堆的高度
\item 原地操作 
\end{DoxyItemize}

Definition at line 116 of file minqueue.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a4ddfab80f781d5b5f7544164bf266f82}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!heapify@{heapify}}
\index{heapify@{heapify}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{heapify(std\+::size\+\_\+t element\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ void {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::heapify (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{element\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a4ddfab80f781d5b5f7544164bf266f82}


heapify：维持堆性质 


\begin{DoxyParams}{Parameters}
{\em element\+Index} & \+: 要维持以该节点为根节点的子堆的堆性质 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void
\end{DoxyReturn}
首先调用比较该节点与左右子节点的最小值。如果最小值为它本身，则维持了性质，返回；如果最小值不是它本身，那么必然为左、右子节点之一。 将该最小节点（假设为左子节点）交换到根节点，然后以左子节点递归调用heapify操作


\begin{DoxyItemize}
\item 时间复杂度 O(n)
\item 原地操作 
\end{DoxyItemize}

Definition at line 265 of file minqueue.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a545dbdb76e0b6e9c4227e558ab9b1239}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!index\+\_\+inqueue@{index\+\_\+inqueue}}
\index{index\+\_\+inqueue@{index\+\_\+inqueue}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{index\+\_\+inqueue(std\+::shared\+\_\+ptr$<$ T $>$ element)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ int {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::index\+\_\+inqueue (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ T $>$}]{element}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a545dbdb76e0b6e9c4227e558ab9b1239}


is\+\_\+inqueue\+:返回指定元素是否在队列中 


\begin{DoxyParams}{Parameters}
{\em element\+:待判定的元素，要求非空。若它为空引用则抛出异常} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
指定元素在队列中的下标
\end{DoxyReturn}
从前到后依次遍历队列，如果队列中某个元素等于{\ttfamily element}，则返回非负整数值， 代表它在队列的std\+::vector中的位置；否则返回-\/1


\begin{DoxyItemize}
\item 时间复杂度 O(h) 
\end{DoxyItemize}

Definition at line 185 of file minqueue.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a0992696959d7300082654529becd1765}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!insert@{insert}}
\index{insert@{insert}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{insert(std\+::shared\+\_\+ptr$<$ T $>$ element)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ int {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::insert (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ T $>$}]{element}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a0992696959d7300082654529becd1765}


insert\+:向队列中插入一个元素 


\begin{DoxyParams}{Parameters}
{\em element} & 待插入元素，如果元素为空引用则直接返回 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: 插入的元素在队列中的位置。若元素为空指针则返回-\/1
\end{DoxyReturn}
插入之前首先判断队列是否已满。若队列已满，则将{\ttfamily \+\_\+data}扩容为大小{\ttfamily \+\_\+size$\ast$2+2}。


\begin{DoxyItemize}
\item 若{\ttfamily \+\_\+size==\+\_\+data.\+size()}则说明队列已满
\end{DoxyItemize}

插入过程为：


\begin{DoxyItemize}
\item 保留待插入元素的{\ttfamily key}，同时将待插入语元素的{\ttfamily key}设置为无穷大，并将待插入元素插入到队尾
\item 执行{\ttfamily decreate\+\_\+key(..)}操作
\end{DoxyItemize}

一旦队列已满，则将队列容量设置为队列长度的一倍（为了防止极端情况，如\+\_\+size=0，此时将队列容量设为队列长度的一倍加上2）


\begin{DoxyItemize}
\item 时间复杂度 O(h)
\item 原地操作 
\end{DoxyItemize}

Definition at line 148 of file minqueue.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a1b484baf6cd011a4b91aa77a644e5a44}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!is\+\_\+empty@{is\+\_\+empty}}
\index{is\+\_\+empty@{is\+\_\+empty}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{is\+\_\+empty()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ bool {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::is\+\_\+empty (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a1b484baf6cd011a4b91aa77a644e5a44}


is\+\_\+empty\+:返回队列是否为空 

\begin{DoxyReturn}{Returns}
队列是否为空
\end{DoxyReturn}
若队列的{\ttfamily \+\_\+size}为0，则队列为空；否则队列不为空


\begin{DoxyItemize}
\item 时间复杂度 O(1) 
\end{DoxyItemize}

Definition at line 170 of file minqueue.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a96293074ee6adef713e9e47059958ea2}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!min@{min}}
\index{min@{min}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{min()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ std\+::shared\+\_\+ptr$<$T$>$ {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::min (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a96293074ee6adef713e9e47059958ea2}


min\+:返回最小值 

\begin{DoxyReturn}{Returns}
最小值的强引用
\end{DoxyReturn}
根据最小堆的性质，队列的第一个值就是最小值的强引用。如果队列为空，则返回一个空引用


\begin{DoxyItemize}
\item 时间复杂度 O(1) 
\end{DoxyItemize}

Definition at line 92 of file minqueue.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a9a432c7c167a4f9a56c2988cfdc04620}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!setup\+Heap@{setup\+Heap}}
\index{setup\+Heap@{setup\+Heap}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{setup\+Heap()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ void {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::setup\+Heap (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a9a432c7c167a4f9a56c2988cfdc04620}


setup\+Heap\+:建堆 

\begin{DoxyReturn}{Returns}
void
\end{DoxyReturn}
从后一半的元素开始依次向前调用heapify操作（根据最小堆性质，除了最底层它是完全充满的）


\begin{DoxyItemize}
\item 时间复杂度 O(nlogn)
\item 原地操作 
\end{DoxyItemize}

Definition at line 243 of file minqueue.\+h.



\subsection{Member Data Documentation}
\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a5de60762d317fc92c18e882dd50f8dfa}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!\+\_\+compare@{\+\_\+compare}}
\index{\+\_\+compare@{\+\_\+compare}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{\+\_\+compare}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ {\bf Compare\+Type} {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::\+\_\+compare\hspace{0.3cm}{\ttfamily [private]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a5de60762d317fc92c18e882dd50f8dfa}
一个可调用对象，可用于比较两个std\+::shared\+\_\+ptr$<$\+T$>$的小于比较 

Definition at line 371 of file minqueue.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_ad463395cef741624e6d078e4e4fc624f}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!\+\_\+data@{\+\_\+data}}
\index{\+\_\+data@{\+\_\+data}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{\+\_\+data}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ std\+::vector$<$std\+::shared\+\_\+ptr$<$T$>$ $>$ {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::\+\_\+data\hspace{0.3cm}{\ttfamily [private]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_ad463395cef741624e6d078e4e4fc624f}
最小优先级队列的数据 

Definition at line 369 of file minqueue.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a3f791f9dd9d61dc2caf1d6b2b354f4c4}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!\+\_\+get\+Key@{\+\_\+get\+Key}}
\index{\+\_\+get\+Key@{\+\_\+get\+Key}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{\+\_\+get\+Key}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ {\bf Get\+Key\+Type} {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::\+\_\+get\+Key\hspace{0.3cm}{\ttfamily [private]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a3f791f9dd9d61dc2caf1d6b2b354f4c4}
一个可调用对象，可用于获取std\+::shared\+\_\+ptr$<$\+T$>$的关键字，并修改该关键字（返回的是关键字的引用） 

Definition at line 372 of file minqueue.\+h.

\hypertarget{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a0de92802e37516dda2c01de776aba641}{}\index{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}!\+\_\+size@{\+\_\+size}}
\index{\+\_\+size@{\+\_\+size}!Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue@{Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}}
\subsubsection[{\+\_\+size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, typename T\+Key\+Type$>$ std\+::size\+\_\+t {\bf Introduction\+To\+Algorithm\+::\+Queue\+Algorithm\+::\+Min\+Queue}$<$ T, T\+Key\+Type $>$\+::\+\_\+size\hspace{0.3cm}{\ttfamily [private]}}\label{class_introduction_to_algorithm_1_1_queue_algorithm_1_1_min_queue_a0de92802e37516dda2c01de776aba641}
堆大小 

Definition at line 370 of file minqueue.\+h.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/queue\+\_\+algorithms/min\+\_\+queue/\hyperlink{minqueue_8h}{minqueue.\+h}\end{DoxyCompactItemize}
