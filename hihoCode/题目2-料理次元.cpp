/*
时间限制:10000ms
单点时限:1000ms
内存限制:256MB
描述
小Hi最近沉迷料理不能自拔，料理可以看做对5种食物进行烹饪、摆盘的过程。作为一名主厨，制作料理对于小Hi来说不在话下，问题是如何将制作好的食物进行合适的摆盘，使它们形成一个完美的套餐。

在一份套餐中，小Hi会制作5种食物，食物可以分为六大类：主食、主菜、副菜、甜点、头盘以及汤饮。随后小Hi会进行摆盘，套餐的盘子是一个如下形状的多边形，每个格子中至多能放置一种食物，即小Hi需要对于每种食物选择一个不同的格子进行放置。

1.png

在摆盘过程中，对于一种制作的食物，如果在摆盘中满足它的激活条件，就能够使这个食物的味道变得特别棒！一种食物的激活条一般包含两部分：首先是摆在这种食物周围的食物数量大于等于一定值，其次是这种食物与特定的一类食物相邻。

现在小Hi告诉你他制作的N种食物的类型以及激活条件，希望你帮他计算在装盘过程中最多能够同时满足多少种食物的激活条件？

输入
第一行为一个正整数T，表示小Hi制作的套餐数。

对于每个套餐一共有5行数据，每行描述小Hi制作的一种食物。

每行的第一个整数A描述这种食物的类型，A为0~5范围内的整数，分别表示这种食物的类型是主食/主菜/副菜/甜点/头盘/汤饮，第二个整数B描述激活这种食物至少需要在其周围的格子中摆下至少B种食物，接下来的6个整数C0~C5分别描述激活这种食物是否需要与主食/主菜/副菜/甜点/头盘/汤饮相邻，其中0表示不需要，1表示需要。

对于100%的数据，满足T ≤ 5, 0 ≤ B ≤ 7

输出
对于每个套餐，输出在装盘过程中最多能够同时满足激活条件的食物数量。

样例输入
1
0 2 0 0 0 0 1 0
1 2 0 0 0 1 0 0
2 3 0 0 1 0 0 0
3 3 0 1 0 0 0 0
4 3 1 0 0 0 0 0
样例输出
4
*/


#include<bits/stdc++.h>
using namespace std;

int ans;
int a[10];
int b[10];
int c[10];
int u[20];
vector<int> G[20];
void in(int i, int j){
	G[i].push_back(j);
	G[j].push_back(i);
}
//bool ch(){
//    return u[]==0
//    && u[]==1
//    && u[]==2
//    && u[]==3
//    && u[]==4;
//}
void dfs(int x){
	if (x == 5){
		int num = 0;
		for (int i = 0; i <= 12; ++i){
			if (~u[i]){
				int nn = 0, mm = 0;
				for (auto &e : G[i]){
					if (~u[e]){
						nn |= 1 << a[u[e]];
						++mm;
					}
				}
				int id = u[i];
				//        if(ch())printf("%d %d %d %d %d\n",i,mm,b[id],c[id],c[id]&nn);
				if (mm < b[id])continue;
				if ((c[id] & nn) != c[id])continue;
				++num;
			}
		}
		//        printf("%d\n",num);
		if (ans < num)ans = num;
		return;
	}
	for (int i = 0; i <= 12; ++i){
		if (u[i] == -1){
			u[i] = x;
			dfs(x + 1);
			u[i] = -1;
		}
	}
}
int main(){
	in(0, 2);
	in(0, 3);
	in(1, 5);
	in(2, 5);
	in(2, 6);
	in(3, 6);
	in(3, 7);
	in(4, 7);
	in(5, 8);
	in(5, 9);
	in(6, 9);
	in(6, 10);
	in(7, 10);
	in(7, 11);
	in(9, 12);
	in(10, 12);
	in(1, 2);
	in(2, 3);
	in(3, 4);
	in(5, 6);
	in(6, 7);
	in(8, 9);
	in(9, 10);
	in(10, 11);
	int T;
	scanf("%d", &T);
	while (T--){
		for (int i = 0; i < 5; ++i){
			scanf("%d%d", &a[i], &b[i]);
			c[i] = 0;
			for (int j = 0, k; j < 6; ++j){
				scanf("%d", &k);
				if (k)c[i] |= 1 << j;
			}
		}
		memset(u, -1, sizeof u);
		ans = 0;
		dfs(0);
		printf("%d\n", ans);
	}
	return 0;
}
