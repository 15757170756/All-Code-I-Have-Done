http://www.xluos.com/index.php/archives/606/

并查集
并查集的定义
并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。
集就是让每个元素构成一个单元素的集合，也就是按一定顺序将属于同一组的元素所在的集合合并。

并查集的用途
维护一个无向图的连通性，判断n个点m条边时最少加多少边可以连通所有点
判断在一个无向图中，两点间加边是否会产生环（最小生成树克鲁斯卡尔中有用到）
维护集合等操作
等等等等。。。。
并查集的操作
所谓并查集，并查集。顾名思义操作就两种：

并：合并两个集合
查：查找两个元素是否在一个集合（或者说查找元素的根节点）
关于并查集的原理，先看一个小故事，具体出处已经找不到了，网上找到的最早的是12年的一个博客，那个博主也表示不知道出处，
不过这个故事确实很生动了解释了并查集的原理，表示文笔上比不过原作者还是依然决然转过来了。

话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，
就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，
只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，
通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。
但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？

我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“齐达内朋友之队”
“罗纳尔多朋友之队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。

但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：
“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。
队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。
遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，
至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。
于是，门派产生了。

人物关系图

下面我们来看并查集的实现。

int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），
pre[15] = 3就表示15号大侠的上级是3号大侠。
如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。
也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。
每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！
要想知道自己的掌门是谁，只能一级级查上去。
 find这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。

int find(int x)                    //查找我（x）的掌门
{
	int r = x;                      //委托 r 去找掌门
	while (pre[r] != r)           //如果r的上级不是r自己（也就是说找到的大侠他不是掌门 = =）
		r = pre[r];                 // r 就接着找他的上级，直到找到掌门为止。
	return  r;                //掌门驾到~~~
}
再来看看join函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。
这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 
还是举江湖的例子，假设现在武林中的形势如图所示。虚竹小和尚与周芷若MM是我非常喜欢的两个人物，
他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，
就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，
整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，
我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，
那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”
玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”抗议无效，上天安排的，最大。
反正谁加入谁效果是一样的，我就随手指定了一个。这段函数的意思很明白了吧？

并操作原理图

void join(int x, int y)          //我想让虚竹和周芷若做朋友
{
	int fx = find(x), fy = find(y);         //虚竹的老大是玄慈，芷若MM的老大是灭绝
	if (fx != fy)                         //玄慈和灭绝显然不是同一个人
		pre[fx] = fy;                       //方丈只好委委屈屈地当了师太的手下啦
}
关于合并操作的一个优化：
如果是按照这样强行指定一个树合并的另一个树中而不加以判断，那么很容易造出一个极不平衡的树，就像下图一样
图像 2.png
接前面的例子来说，玄慈很火大的说凭什么让我当他的手下，明明我的人手比她多，不行我不服，
为了平息方丈的怨气懒懒的老天终于又加了一项规定，门派人手少的给人手多的当手下，人手相同时候老天指定。
终于这样大家都满意了，这样就保证了树可以维持在一个比较平衡的程度。
代码如下：

// rank[]初始化是都为0或1，代表手下的人数
void join(int x, int y)          //我想让虚竹和周芷若做朋友
{
	int fx = find(x), fy = find(y);         //虚竹的老大是玄慈，芷若MM的老大是灭绝
	if (fx != fy)                         //玄慈和灭绝显然不是同一个人
	{
		if (rank[fx] >= rank[fy])        //俩人开始比谁的手下多
			｛
			pre[fx] = fy;                       //方丈技不如人当了师太的手下
		rank[fy] += rank[fx];            //方丈的手下都归师太
			｝
		else
		{
			pre[fy] = fx;                       //师太人数比不过当了方丈的手下啦
			rank[fx] += rank[fy];              //师太的手下都归方丈
		}
	}
}
关于按照秩来合并也有按照树的层数来合并，这样可以把查询的次数保持在log的水平，但是如果同时用了路径压缩的话，
树的层数就很难维护，所以我这里采用子孙节点的数量来维护。

再来看看路径压缩算法。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。
最后的树状结构会变成什么胎唇样，我也完全无法预计，一字长蛇阵也有可能。这样查找的效率就会比较低下。
最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。
这样就产生了路径压缩算法。 设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能揍。
于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 
一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是记己人，西礼西礼，在下三营六组白面葫芦娃!” 
“幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位同学请留步，
还有事情没完成呢！”
我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 
白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其习偶们的掌门是曹公公。
不如偶们一起及接拜在曹公公手下吧，省得级别太低，以后查找掌门麻环。” “唔，有道理。” 
白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 
这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。
每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。
查询和路径压缩都有递归和非递归两种方法，递归好写，非递归好懂。
什么时候用那个视情况而定。
路径压缩原理

// 非递归写法
int find(int x)
{
	int r = x;
	while (r != pre[r])
		r = pre[r];

	int i = x, j;
	while (pre[i] != r)  //如果说不是掌门
	{
		j = pre[i];    //存下这位大虾的上级
		pre[i] = r;    //告诉这位大虾掌门是谁
		i = j;         //去找大虾的上级告诉他掌门是谁
	}
	return r;
}
//递归写法
int find(int x)
{
	if (pre[x] != x)
	{
		pre[x] = find(pre[x]);  //找的祖先递归赋值，将本次查找经过的每个节点都直接连到祖先节点上
	}
	return pre[x];
}
并查集的删除
一般来说，并查集的并、查两个功能在80%的场景中都是就够用的，但是你保不准万一那天那个大虾发现了盟主是自己多年前的杀父仇人想要出联盟
，发现自己都没办法叛逃了多难受。
对于删除操作，在完美的并查集中（所有节点都直接连接在根节点上）理论上只要把要删除的节点的上级重新指向自己就可以了。
但是实际情况中，我们的并查集形成的树的形态都是不可预估形态的，如果直接将一个节点指向自己可能会将他的“下级”和他一块删除，
这就和我们的想法违背了。所以在一个需要删除的并查集中初始化时就要处理一下：

首先每个节点不再指向自己而是另一个比不会出现的节点，类似于将每个节点放到一个盒子中
这样，删除时只需要把这个节点从当前盒子拿出来，放到另一个盒子中
由于节点之间都是通过盒子来确定关系的，所以盒子中元素是否存在并不影响节点之间的关系
于是我们就找到了，并查集中删除某个节点的方法，我把它形象的成为“找假爹”，因为每一个祖先节点都相当于假的嘛。
把每个节点都套入一个盒子中，他们之间的关系并不会改变
节点套入盒子

如果要删除2号节点，那么我们把2拿出来放到另一个盒子中就可以了，可以看到原来的那个树结构并没有发生变化。但是2已经不在这里面了
删除节点图

但是要怎么找这些假节点呢，很简单，假设最多会有1000个节点就从1001开始作为假节点，初始化就变成了这样

int index;   //存放盒子节点使用到哪一个了
void init(int n)
{
	index = n;
	for (int i = 0; i < n; i++)     //普通节点指向他的盒子节点
		pre[i] = index++;
	for (int i = n; i < 2 * n; i++)   //盒子节点指向自己就像一般的并查集一样
		pre[i] = i;
}

void del(int n)
{
	pre[n] = index;   //将要删除的节点重新指向一个新的盒子
	pre[index] = index++;   //盒子节点指向自己
}
注意： 这样操作节点的数量一定要保证足够大，否则当删除操作越来越多的时候，节点不够用就会运行错误了。
当然还有一种方法就是动态维护节点的数量来将那些被删除过的“空盒子”重新利用起来。

acm 并查集 数据结构














OpenCV的不相交集合
class DisjointSets
{
public:
	DisjointSets(int elem_count = 0) { createOneElemSets(elem_count); }

	void createOneElemSets(int elem_count);
	int findSetByElem(int elem);
	int mergeSets(int set1, int set2);

	std::vector<int> parent;
	std::vector<int> size;

private:
	std::vector<int> rank_;
};

void DisjointSets::createOneElemSets(int n)
{
	rank_.assign(n, 0);
	size.assign(n, 1);
	parent.resize(n);
	for (int i = 0; i < n; ++i)
		parent[i] = i;
}


int DisjointSets::findSetByElem(int elem)
{
	int set = elem;
	while (set != parent[set])
		set = parent[set];
	int next;

	/*
	路径压缩：使得所有原来是下级的下级的下级
	直接归属于老大
	*/
	while (elem != parent[elem])
	{
		next = parent[elem];
		parent[elem] = set;
		elem = next;
	}
	return set;
}


int DisjointSets::mergeSets(int set1, int set2)
{
	if (rank_[set1] < rank_[set2])
	{
		parent[set1] = set2;
		size[set2] += size[set1];
		return set2;
	}
	if (rank_[set2] < rank_[set1])
	{
		parent[set2] = set1;
		size[set1] += size[set2];
		return set1;
	}
	parent[set1] = set2;
	rank_[set2]++;
	size[set2] += size[set1];
	return set2;
}