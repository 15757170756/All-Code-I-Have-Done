#include <iostream>

using namespace::std;

// A utility function that returns maximum of two integers
int max(int a, int b) { return (a > b) ? a : b; }

// Returns the maximum value that can be put in a knapsack of capacity W
int knapSack(int W, int wt[], int val[], int n)
{
	int** K = new int*[n + 1];
	for (int i = 0; i < n + 1; ++i)
		K[i] = new int[W + 1];

	for (int i = 0; i <= n; ++i) {
		for (int w = 0; w <= W; ++w) {
			if (i == 0 || w == 0)
				K[i][w] = 0;
			else if (wt[i - 1] <= w)
				K[i][w] = max(K[i - 1][w - wt[i - 1]] + val[i - 1],
				K[i - 1][w]);
			else
				K[i][w] = K[i - 1][w];
		}
	}

	int maxValue = K[n][W];

	for (int i = 0; i < n + 1; ++i)
		delete[] (int*)K[i];
	delete[] K;

	return maxValue;
}

int main()
{
	int val[] = { 60, 100, 120 };
	int wt[] = { 10, 20, 30 };
	int W = 50;
	int n = sizeof(val) / sizeof(val[0]);
	cout << knapSack(W, wt, val, n) << endl;

	return 0;
}





/*
样例输入
5 1000
144 990
487 436
210 673
567 58
1056 897
样例输出
2099
*/
//只需要一维数组
#include <iostream>
#include <vector>
#include <fstream>

using namespace::std;

int max(int a, int b) { return (a > b) ? a : b; }

int knapSack(int W, vector<int> &wt, vector<int> &val, int n)
{
	vector<int> K(W + 1, 0);
	for (int i = 0; i < n; ++i)
		for (int j = W; j >= wt[i]; --j)
			K[j] = max(K[j], K[j - wt[i]] + val[i]);

	return K[W];
}

int main()
{
	ifstream in("input.txt");
	int n, Weight;
	cin >> n >> Weight;
	vector<int> value, wt;
	for (int i = 0; i < n; ++i) {
		int tempValue, tempWt;
		cin >> tempWt >> tempValue;
		value.push_back(tempValue);
		wt.push_back(tempWt);
	}
	//for (int i = 0; i < n; ++i)
	//	cout << wt[i] << ' ' << value[i] << endl;

	cout << knapSack(Weight, wt, value, n) << endl;

	return 0;
}

/*
假设山洞里共有a,b,c,d ,e这5件宝物（不是5种宝物），
它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，
现在给你个承重为10的背包, 怎么装背包，可以才能带走最多的财富。

有编号分别为a,b,c,d,e的五件物品，它们的重量分别是2,2,6,5,4，
它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包，
如何让背包里装入的物品具有最大的价值总和？

name weight	value	1	2	3	4	5	6	7	8	9	10
a	    2	   6	0	6	6	9	9	12	12	15	15	15
b	    2	   3	0	3	3	6	6	9	9	9	10	11
c	    6	   5	0	0	0	6	6	6	6	6	10	11
d	    5	   4	0	0	0	6	6	6	6	6	10	10
e	    4	   6	0	0	0	6	6	6	6	6	6	6

name weight	value	0   1	2	3	4	5	6	7	8	9	10
                    0   0	0	0	0	0	0	0	0	0	0
e	    4	   6	0   0	0	0	6	6	6	6	6	6	6
d	    5	   4	0   0	0	0	6	6	6	6	6	10	10
c	    6	   5	0   0	0	0	6	6	6	6	6	10	11
b	    2	   3	0   0	3	3	6	6	9	9	9	10	11
a	    2	   6	0   0	6	6	9	9	12	12	15	15	15

只要你能通过找规律手工填写出上面这张表就算理解了01背包的动态规划算法。
首先要明确这张表是至底向上，从左到右生成的。
为了叙述方便，用e2单元格表示e行2列的单元格，
这个单元格的意义是用来表示只有物品e时，有个承重为2的背包，
那么这个背包的最大价值是0，因为e物品的重量是4，背包装不了。

对于d2单元格，表示只有物品e，d时,承重为2的背包,所能装入的最大价值，
仍然是0，因为物品e,d都不是这个背包能装的。

同理，c2=0，b2=3,a2=6。

对于承重为8的背包，a8=15,是怎么得出的呢？

根据01背包的状态转换方程，需要考察两个值，

一个是f[i-1,j],对于这个例子来说就是b8的值9，另一个是f[i-1,j-Wi]+Pi；
在这里，f[i-1,j]表示我有一个承重为8的背包，当只有物品b,c,d,e四件可选时，
这个背包能装入的最大价值

f[i-1,j-Wi]表示我有一个承重为6的背包（等于当前背包承重减去物品a的重量），
当只有物品b,c,d,e四件可选时，这个背包能装入的最大价值

f[i-1,j-Wi]就是指单元格b6,值为9，Pi指的是a物品的价值，即6

由于f[i-1,j-Wi]+Pi = 9 + 6 = 15 大于f[i-1,j] = 9，
所以物品a应该放入承重为8的背包

以下是actionscript3 的代码
*/








/*
提示一：合理抽象问题、定义状态是动态规划最关键的一步
小Hi想了想，问道：“你打算怎么做？”

“枚举2^N种可能的选取方案，先计算他们需要的奖券之和sum，在sum不超过M的情况下，计算他们的喜好值之和value，并统计一个最优的方案，也就是value的最大值！”天真的小Ho给出了一个同样天真的方案。

“简直白教你动态规划了……”小Hi不禁扶额道：“这道题目你还是考虑一下如何使用动态规划来解决吧！”

“好的！让我回忆一下……动态规划要求问题存在两种性质：重复子问题和无后效性~但是...我怎么也看不出这道题目怎么套上这两种性质呀，什么样算是一个子问题？”小Ho想了想，说道。

“先别急，你想要知道子问题是什么？那么首先，我们要想办法把我们现在遇到的问题给抽象化！”

小Ho低头思索了一会，说道：“唔，我想想，如果用best(x)表示手中有x张奖券时能够获取的最高的喜好值的和，那么我们的问题就是best(M)是多少？”

“你这样定义的话，是没有办法把‘求解best(M)’这样一个问题分解成不同的子问题的哦~”小Hi笑道：“也罢，初学者往往都很难自己想出如何好的抽象问题，这次就让我先来告诉你~”

“就知道卖关子~快说！”

小Hi笑了笑，继续说道：“这个问题——best(M)的求解，其实问的便是每个奖品是否选择是么？那么你在遍历这2^N种可能的选取方案的时候，是不是按照顺序，一一确定每一个奖品是否选取？”

“是的！”

小Hi继续道：“那么我们不妨就按照你遍历时的情况来，不过做一点小改动，以best(i, x)表示已经决定了前i件物品是否选取，当前已经选取的物品的所需奖券数总和不超过x时，能够获取的最高的喜好值的和。”

“听起来的确和搜索很像，搜索时就是按照编号从小到大的顺序一一决定每件物品是否选取，并且维护一个当前已经选取的物品的所需奖券书的总和。”忽然小Ho似乎想到了什么：“诶，那么这个best(i, x)其实就是和之前遇到的数字三角形迷宫问题中用于解决问题的记忆化搜索很相似的？”

“没错，记忆化搜索的确就是和动态规划极为相似，或者可以说，他们用以解决问题的原理是一样的。”小Hi回答道。

“原来如此，我想想……那么最终的答案其实就是best(N, M)是么？”小Ho得出了结论。

“是的！这个时候我们就可以称best(N, M)的求解为我们的问题了！”小Hi高兴道。

“那么子问题呢？”

小Hi挥了挥手示意小Ho不要着急：“子问题通常会采取将问题分成若干部分来进行，有的时候是均分，也有的时候仅仅是在规模上减一。比如这里，我们不妨考虑best(N, M)这个问题的最后一个决策——第N件奖品是否进行选择：首先，如果选择第N件奖品，当然首先要保证第N件商品所需的奖券数不超过M，我们可以知道这种方案的最佳收益为best(N - 1, M - need(N)) + value(N)。”

“其次呢，如果不选择第N件奖品，我们可以知道这种方案的最佳收益为best(N - 1, M)。”小Hi顿了顿，继续道：”由于第N件奖品只有选取和不选取两种可能，我们于是可以知道best(N, M) = max{best(N - 1, M - need(N)) + value(N), best(N - 1, M)}！”

“没错！”小Ho道：“同样的道理，对于任意i>1, j，我们都可以知道best(i, j)=max{best(i-1, j-need(i)) + value(i), best(i - 1, j)}!”

“归纳的不错！那么你接检验一下这个问题的定义方法是否拥有动态规划所需要的两种性质？”

小Ho想了想，决定一条一条的来：“首先看重复子问题——这是动态规划之所以比搜索高效的原因，如果最后四件奖品分别为所需奖券为1，喜好值为1、所需奖券为2，喜好值为2、所需奖券为3，喜好值为3、所需奖券为4，喜好值为4的四个奖品，那么无论是选择1、4还是2、3，都会要求解best(N-4, M-5)这样一个子问题，而这个子问题只需要求解一次就能够进行计算，所以重复子问题这一性质是满足的。”

“没错，接着说。”

“其次再看无后效性……同样的，如果分别有所需奖券为1，喜好值为1、所需奖券为2，喜好值为2、所需奖券为3，喜好值为3、所需奖券为4，喜好值为4的四个奖品，那么无论是选取第1个和第4个，还是选取第2个和第3个，他们的所需奖券数都为5，喜好值之和都为5。所以我只需要知道best(4, 5)=5就够了，它为什么等于5对我而言没有区别，不会对之后的决策产生影响。这就是无后效性，所以想来也是满足的。

“说的挺正确~那么接下来要考虑的是如何使用best(i, j)=max{best(i-1, j-need(i)) + value(i), best(i - 1, j)}来求解每一个best(i, j)了~”小Hi道：“这部分我便直接告诉你吧，我们定义一个问题A依赖于另一个问题B当且仅当求解A的过程中需要事先知道B的值，那么我们很容易的发现best(i, j)是依赖于best(i-1, j-need(i))和best(i-1, j)两个问题的，也就是说这两个问题要先于best(i, j)进行求解~”

“所以我们只要按照i从小到大的顺序，以这样的方式进行计算，就可以了！”小Ho插嘴道。

伪代码一.png
“你又抢我台词！”
*/