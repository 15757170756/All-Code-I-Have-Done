腾讯2012校招笔试题目中两道选择题，如下， 求输出结果

1、

#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
	for (int i = 0; i<2; i++){
		fork();
		printf("-");
	}
	return 0;
}

输出结果为 8个“ - ”


2、
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
	for (int i = 0; i<2; i++) {
		fork();
		printf("-\n");
	}
	return 0;
}

输出结果为 6个“ - ”



很纳闷，为什么一个\n换行符会对输出结果产生影响呢？究其原因就得考究fork函数是如何产生子进程。
在执行fork以后，操作系统复制一份当前执行的进程的数据，包括进程的数据空间、堆和栈等，
并且在进程表中相应为它建立一个新的表项。上下文也是原进程（父进程）的拷贝。
但是父、子进程共享正文段，也就是CPU执行的机器指令部分，这个可共享的，
在存储器中只需要一个副本，而且这个副本通常是只读的。
所以子进程函数执行点是从父进程中调用fork函数开始往下执行的。
关于这一点，理解父子进程关系的话，应该不难理解。
而这个\n换行符对输出产生的影响则是和printf函数的缓冲机制有关。
当调用printf函数的时候，函数中的输出数据是先被放入缓冲区中，
而并没有直接输出到屏幕，直到往缓冲区中压入\n换行符或者是调用了flush之类的函数，才
会把数据输出到屏幕。而这个缓冲区在每个子进程都拥有一份副本。所以现在就知道该如何分析了。


首先，先分析没有加\n换行符的函数，i = 0时，父进程调用fork函数，
此时父进程中的缓冲区中有0个“ - ”，其子进程2中的上下文与父进程相同，
因此子进程将执行1次FOR循环，此时，该进程缓冲区拥有1个“ - ”，并再次调用fork产生新的子进程3，
上下文内容与产生其的父进程相同，也就是缓冲区中拥有一个“ - ”，但是此时i = 1，
新产生的子进程将不再执行for循环。回到主进程，也就是一个父进程，
父进程将执行两次for循环，第二次for循环将产生一个新的子进程4，
其缓冲区中有一个“ - ”。最后别忘了每一个进程都是从fork调用点开始执行的，
所以每个进程都会输出一个“ - ”，加起来就是8个了。
对于程序2，则在上述分析过程中，注意一下缓冲区中的数据何时被清理，就可以算出结果了。


#include "stdio.h"
#include "sys/types.h"
#include "unistd.h"

int main()
{
	pid_t pid1;
	pid_t pid2;

	pid1 = fork();
	pid2 = fork();

	printf("pid1:%d, pid2:%d\n", pid1, pid2);
}


/*********************************
output:
pid1:20681, pid2:20682
pid1:20681, pid2:0
pid1:0, pid2:20683
pid1:0, pid2:0
********************************/